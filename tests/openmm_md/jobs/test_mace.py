from collections.abc import Callable
from pathlib import Path

import openmm
import openmm.unit as omm_unit
import pytest
from emmet.core.openmm.tasks import OpenMMInterchange, OpenMMTaskDocument
from jobflow import JobStore, run_locally
from numpy.testing import assert_allclose
from pymatgen.core import Structure

from atomate2.forcefields.utils import revert_default_dtype
from atomate2.openmm.flows import OpenMMFlowMaker
from atomate2.openmm.jobs import EnergyMinimizationMaker, NPTMaker, NVTMaker


@pytest.mark.openmm_mace
def test_generate_openmm_interchange(
    task_doc: OpenMMTaskDocument, random_structure: Structure
) -> None:
    assert_allclose(
        task_doc.structure.frac_coords, random_structure.frac_coords, atol=0.01
    )
    interchange = OpenMMInterchange.model_validate_json(task_doc.interchange)
    integrator = openmm.LangevinIntegrator(
        300 * omm_unit.kelvin, 10.0 / omm_unit.picoseconds, 1.0 * omm_unit.femtosecond
    )
    platform = openmm.Platform.getPlatformByName("CPU")

    sim = interchange.to_openmm_simulation(integrator, platform)
    assert isinstance(sim, openmm.app.Simulation)


@pytest.mark.openmm_mace
def test_nvt_maker(task_doc: OpenMMInterchange) -> None:
    # the task document in the fixture is generated by an nvt maker

    # Test length of state attributes in calculation output
    calc_output = task_doc.calcs_reversed[0].output
    assert len(calc_output.steps_reported) == 2

    # Test that the state interval is respected
    assert calc_output.steps_reported == list(range(1, 3))


@pytest.mark.openmm_mace
def test_npt_maker(interchange: OpenMMInterchange, run_job: Callable) -> None:
    # this is validated upstream in atomate2, we are ensuring it works with mace
    maker = NPTMaker(n_steps=2, state_interval=1, pressure=0)
    base_job = maker.make(interchange)
    with revert_default_dtype():
        run_job(base_job)


@pytest.mark.openmm_mace
def test_energy_minimization_maker(
    interchange: OpenMMInterchange, run_job: Callable
) -> None:
    # this is validated upstream in atomate2, we are ensuring it works with mace
    maker = EnergyMinimizationMaker(max_iterations=1)
    base_job = maker.make(interchange)
    with revert_default_dtype():
        run_job(base_job)


@pytest.mark.openmm_mace
def test_flow_maker(
    interchange: OpenMMInterchange, job_store: JobStore, tmp_path: Path
):
    # this is validated upstream in atomate2, we are ensuring it works with mace
    production_maker = OpenMMFlowMaker(
        name="test_production",
        tags=["test"],
        makers=[
            NVTMaker(
                n_steps=1,
                state_interval=1,
                traj_interval=1,
                temperature=5000,
            ),
            NVTMaker(n_steps=1),
        ],
    )

    # Run the ProductionMaker flow
    production_flow = production_maker.make(interchange)
    # task_doc = run_job(production_flow)

    with revert_default_dtype():
        response_dict = run_locally(
            production_flow, store=job_store, ensure_success=True, root_dir=tmp_path
        )
    task_doc = list(response_dict.values())[-1][1].output

    # Check the output task document
    assert isinstance(task_doc, OpenMMTaskDocument)
    assert task_doc.state == "successful"
    assert len(task_doc.calcs_reversed) == 2
    assert task_doc.calcs_reversed[-1].task_name == "nvt simulation"
    assert task_doc.calcs_reversed[0].task_name == "nvt simulation"
    assert task_doc.tags == ["test"]
    assert len(task_doc.job_uuids) == 2
    assert task_doc.job_uuids[0] is not None
