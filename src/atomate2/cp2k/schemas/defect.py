from datetime import datetime
from tokenize import group
from typing import ClassVar, TypeVar, Type, Dict, Tuple, Mapping, List
from pydantic import BaseModel, Field
from pydantic import validator
from itertools import groupby

from monty.json import MontyDecoder 
from monty.tempfile import ScratchDir

from pymatgen.core import Structure
from pymatgen.entries.computed_entries import ComputedStructureEntry
from pymatgen.analysis.defects.core import Defect
from pymatgen.analysis.defects.corrections import get_freysoldt_correction, get_freysoldt2d_correction
from pymatgen.analysis.defects.thermo import DefectEntry, DefectSiteFinder
from pymatgen.symmetry.analyzer import SpacegroupAnalyzer
from atomate2 import SETTINGS

from atomate2.common.schemas.structure import StructureMetadata
from atomate2.cp2k.schemas.calc_types.utils import run_type, task_type, calc_type
from atomate2.cp2k.schemas.calc_types.enums import CalcType, TaskType, RunType
from atomate2.cp2k.schemas.task import TaskDocument

__all__ = ["DefectDoc"]

T = TypeVar("T", bound="DefectDoc")

class DefectDoc(StructureMetadata):
    """
    A document used to represent a single defect. e.g. a O vacancy with a -2 charge.
    This document can contain an arbitrary number of defect entries, originating from
    pairs (defect and bulk) of calculations. This document provides access to the "best"
    calculation of each run_type.
    """

    property_name: ClassVar[str] = "defect"

    defect: Defect = Field(None, description="Pymatgen defect object for this defect doc")

    name: str = Field(None, description="Name of this defect as generated by the defect object")

    material_id: str = Field(None, description="Unique material ID for the bulk material") #TODO Change to MPID

    # TODO Should it be all (defect + bulk) ids?
    task_ids: List[str] = Field(
        None, description="All defect task ids used in creating this defect doc."
    )

    calc_types: Mapping[str, CalcType] = Field(  # type: ignore
        None,
        description="Calculation types for all the calculations that make up this material",
    )
    task_types: Mapping[str, TaskType] = Field(
        None,
        description="Task types for all the calculations that make up this material",
    )
    run_types: Mapping[str, RunType] = Field(
        None,
        description="Run types for all the calculations that make up this material",
    )

    best_tasks: Mapping[RunType, Tuple[str, str]] = Field(
        None, description="Task ids (defect task, bulk task) for all tasks of a RunType"
    )

    all_tasks: Mapping[RunType, List[Tuple[str, str]]] = Field(
        None, description="Task ids (defect task, bulk task) for all tasks of a RunType"
    )

    entries: Mapping[RunType, DefectEntry] = Field(
        None, description="Dictionary for tracking entries for CP2K calculations"
    )

    last_updated: datetime = Field(
        description="Timestamp for when this document was last updated",
        default_factory=datetime.utcnow,
    )

    created_at: datetime = Field(
        description="Timestamp for when this material document was first created",
        default_factory=datetime.utcnow,
    )

    metadata: Dict = Field(description="Metadata for this defect")

    # TODO How can monty serialization incorporate into pydantic? It seems like VASP MatDocs dont need this
    @validator("entries", pre=True)
    def decode(cls, entries):
        for e in entries:
            if isinstance(entries[e], dict):
                entries[e] = MontyDecoder().process_decoded({k: v for k, v in entries[e].items()})
        return entries

    def update(self, defect_task, bulk_task, dielectric, query='defect'):

        defect_task_doc = TaskDocument(**defect_task)
        bulk_task_doc = TaskDocument(**bulk_task)

        rt = defect_task_doc.run_type
        tt = defect_task_doc.task_type
        ct = defect_task_doc.calc_type

        # Metadata
        last_updated = max(dtsk.last_updated for dtsk, btsk in self.tasks.values()) if self.tasks else datetime.now()
        created_at = min(dtsk.last_updated for dtsk, btsk in self.tasks.values()) if self.tasks else datetime.now()

        if defect_task_doc.task_id in self.task_ids:
            return
        else:
            self.last_updated = last_updated
            self.created_at = created_at
            self.task_ids.append(defect_task_doc.task_id)

            def _run_type(x):
                return run_type(x[0]['input']['dft']).value

            def _compare(new, old):
                # TODO return kpoint density
                return new['nsites'] > old.nsites

            if defect_task_doc.run_type not in self.tasks or _compare(defect_task, self.tasks[rt][0]):
                self.run_types.update({defect_task_doc.task_id: rt})
                self.task_types.update({defect_task_doc.task_id: tt})
                self.calc_types.update({defect_task_doc.task_id: ct})
                entry = self.__class__.get_defect_entry_from_tasks(
                            defect_task=defect_task,
                            bulk_task=bulk_task,
                            dielectric=dielectric,
                            query=query
                        )
                self.entries[rt] = entry
                self.tasks[rt] = (defect_task_doc, bulk_task_doc)

    def update_all(self, defect_tasks: List, bulk_tasks: List, dielectrics: List, query='defect'):
        for defect_task, bulk_task, dielectric in zip(defect_tasks, bulk_tasks, dielectrics):
            self.update(defect_task=defect_task, bulk_task=bulk_task, dielectric=dielectric, query=query)

    @classmethod
    def from_tasks(cls: Type[T], defect_tasks: List, bulk_tasks: List, dielectrics: List, query='defect', key="task_id", material_id=None):
        """
        The standard way to create this document.
        Args:
            tasks: A list of defect,bulk task pairs which will be used to construct a
                series of DefectEntry objects.
            query: How to retrieve the defect object stored in the task.
        """
        defect_task_ids = [defect_task[key] for defect_task in defect_tasks]
        bulk_task_ids = [bulk_task[key] for bulk_task in bulk_tasks]
        bulk_tasks= [TaskDocument(**bulk_task['output']) for bulk_task in bulk_tasks]
        defects = [cls.get_defect_from_task(query=query, task=defect_task) for defect_task in defect_tasks]
        defect_tasks = [TaskDocument(**defect_task['output']) for defect_task in defect_tasks]
        
        # Metadata
        last_updated = datetime.now() or max(task.last_updated for task in defect_tasks)
        created_at = datetime.now() or min(task.completed_at for task in defect_tasks)

        #deprecated_tasks = list(
        #    {task.task_id for task in task_group if not task.is_valid}
        #)

        run_types = {id: task.calcs_reversed[0].run_type for id, task in zip(defect_task_ids, defect_tasks)}
        task_types = {id: task.calcs_reversed[0].task_type for id, task in zip(defect_task_ids, defect_tasks)}
        calc_types = {id: task.calcs_reversed[0].calc_type for id, task in zip(defect_task_ids, defect_tasks)}

        def _run_type(x):
            return x[0].calcs_reversed[0].run_type.value

        def _sort(x):
            # TODO return kpoint density, currently just does supercell size
            return -x[0].nsites, x[0].output.energy

        entries = {}
        all_tasks = {}
        best_tasks = {}
        metadata = {}
        for key, tasks_for_runtype in groupby(sorted(zip(defect_tasks, bulk_tasks, defects, dielectrics, defect_task_ids, bulk_task_ids), key=_run_type), key=_run_type):
            sorted_tasks = sorted(tasks_for_runtype, key=_sort)
            ents = [
                cls.get_defect_entry_from_tasks(defect_task, bulk_task, defect, dielectric) 
                for defect_task, bulk_task, defect, dielectric, did, bid in sorted_tasks
                ]
            rt = run_types[sorted_tasks[0][-2]]
            best_entry = ents[0]
            best_tasks[rt] = (sorted_tasks[0][-2], sorted_tasks[0][-1]) 
            all_tasks[rt] = [ (s[-2], s[-1]) for s in sorted_tasks ]
            metadata[key] = {'convergence': [(sorted_tasks[i][0].nsites, ents[i].corrected_energy) for i in range(len(ents))]}
            entries[rt] = ents[0]

        data = {
                'entries': entries,
                'run_types': run_types,
                'task_types': task_types,
                'calc_types': calc_types,
                'last_updated': last_updated,
                'created_at': created_at,
                'task_ids': defect_task_ids,
                #'deprecated_tasks': deprecated_tasks,
                'all_tasks': all_tasks,
                'best_tasks': best_tasks,
                'material_id': material_id if material_id else best_entry.parameters['material_id'],
                'defect': best_entry.defect,
                'metadata': metadata,
        }
        prim = SpacegroupAnalyzer(best_entry.defect.structure).get_primitive_standard_structure()
        data.update(StructureMetadata.from_structure(prim).dict())
        return cls(**data)

    @classmethod
    def get_defect_entry_from_tasks(cls, defect_task: TaskDocument, bulk_task: TaskDocument, defect: Defect, dielectric=None):
        """
        Extract a defect entry from a single pair (defect and bulk) of tasks.

        Args:
            defect_task: task dict for the defect calculation
            bulk_task: task dict for the bulk calculation
            dielectric: Dielectric doc if the defect is charged. If not present, no dielectric
                corrections will be performed, even if the defect is charged.
            query: Mongo-style query to retrieve the defect object from the defect task
        """
        parameters = cls.get_parameters_from_tasks(defect_task=defect_task, bulk_task=bulk_task)
        if dielectric:
            parameters['dielectric'] = dielectric

        corrections, metadata = cls.get_correction_from_parameters(parameters)

        sc_entry = ComputedStructureEntry(
            structure=parameters['final_defect_structure'], 
            energy=parameters['defect_energy'] - parameters['bulk_energy']
            )

        defect_entry = DefectEntry(
            defect=defect,
            charge_state=parameters['charge_state'],
            sc_entry=sc_entry,
            sc_defect_frac_coords=parameters['defect_frac_sc_coords'],
            corrections=corrections,
        )

        return defect_entry

    @classmethod
    def get_correction_from_parameters(cls, parameters) -> Tuple[Dict, Dict]:
        corrections = {}
        metadata = {}
        for correction in ["get_freysoldt_correction", "get_freysoldt2d_correction"]:
            c, m = getattr(cls, correction)(parameters)
            corrections.update(c)
            metadata.update(m)
        return corrections, metadata

    @classmethod
    def get_freysoldt_correction(cls, parameters) -> Tuple[Dict, Dict]:
        if parameters['charge_state'] and not parameters.get("2d"):
            return get_freysoldt_correction(
                q=parameters['charge_state'], dielectric=parameters['dielectric'], 
                defect_locpot=parameters['defect_v_hartree'], 
                bulk_locpot=parameters['bulk_v_hartree'], 
                defect_frac_coords=parameters['defect_frac_sc_coords'],
                )
        return {}, {}
    
    @classmethod
    def get_freysoldt2d_correction(cls, parameters):

        from pymatgen.io.vasp.outputs import VolumetricData as VaspVolumetricData

        if parameters['charge_state'] and parameters.get("2d"):
            eps_parallel = (parameters['dielectric'][0][0] + parameters['dielectric'][1][1]) / 2
            eps_perp = parameters['dielectric'][2][2]
            dielectric = (eps_parallel - 1) / (1 - 1/eps_perp)
            with ScratchDir('.'):
                
                lref = VaspVolumetricData(structure=parameters['bulk_v_hartree'].structure, data=parameters['bulk_v_hartree'].data)
                ldef = VaspVolumetricData(structure=parameters['defect_v_hartree'].structure, data=parameters['defect_v_hartree'].data)
                lref.write_file("LOCPOT.ref")
                ldef.write_file("LOCPOT.def")

                return get_freysoldt2d_correction(
                    q=parameters['charge_state'], dielectric=dielectric, defect_locpot=ldef, 
                    bulk_locpot=lref, defect_frac_coords=parameters['defect_frac_sc_coords'], 
                    energy_cutoff=520, slab_buffer=2
                    )
        return {}, {}

    @classmethod
    def get_defect_from_task(cls, query, task):
        """
        Unpack a Mongo-style query and retrieve a defect object from a task.
        """
        defect = unpack(query.split('.'), task)
        return MontyDecoder().process_decoded(defect)

    @classmethod
    def get_parameters_from_tasks(cls, defect_task: TaskDocument, bulk_task: TaskDocument):
        """
        Get parameters necessary to create a defect entry from defect and bulk task dicts
        Args:
            defect_task: task dict for the defect calculation
            bulk_task: task dict for the bulk calculation
        """

        final_defect_structure = defect_task.structure
        final_bulk_structure = bulk_task.structure

        ghost = [index for index, prop in enumerate(final_defect_structure.site_properties.get("ghost")) if prop]
        if ghost:
            defect_frac_sc_coords = final_defect_structure[ghost[0]].frac_coords
        else:
            defect_frac_sc_coords = DefectSiteFinder(SETTINGS.SYMPREC).get_defect_fpos(defect_structure=final_defect_structure, base_structure=final_bulk_structure)
        parameters = {
            'defect_energy': defect_task.output.energy,
            'bulk_energy': bulk_task.output.energy,
            'final_defect_structure': final_defect_structure,
            'charge_state': defect_task.output.structure.charge,
            'defect_frac_sc_coords': defect_frac_sc_coords,
            'defect_v_hartree': MontyDecoder().process_decoded(defect_task.cp2k_objects['v_hartree']), # TODO CP2K spec name
            'bulk_v_hartree': MontyDecoder().process_decoded(bulk_task.cp2k_objects['v_hartree']), # TODO CP2K spec name
        }

        if defect_task.tags and "2d" in defect_task.tags:
            parameters['2d'] = True

        return parameters

def unpack(query, d):
    if not query:
        return d
    if isinstance(d, List):
        return unpack(query[1:], d.__getitem__(int(query.pop(0))))
    return unpack(query[1:], d.__getitem__(query.pop(0)))